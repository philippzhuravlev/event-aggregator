import { SecretManagerServiceClient } from '@google-cloud/secret-manager';
import { Timestamp } from '@google-cloud/firestore';
import * as admin from 'firebase-admin';
import { logger } from '../utils/logger';
import { TokenExpiryStatus } from '../types';
import { calculateDaysUntilExpiry, isTokenExpiring, calculateExpirationDate } from '../utils/token-expiry';
import { TOKEN_EXPIRY_CONFIG } from '../utils/constants';

// this is a "service", which sounds vague but basically means a specific piece
// of code that connects it to external elements like facebook, firestore and
// google secret manager. The term could also mean like an intenal service, e.g.
// authentication or handling tokens, but here we've outsourced it to google/meta
// Services should not be confused with "handlers" that do business logic

const secretClient = new SecretManagerServiceClient();

interface StoreTokenOptions {
  db?: admin.firestore.Firestore | null;
  expiresInDays?: number;
}

/**
 * Store a Facebook page access token in Google Secret Manager
 * Also stores metadata about token expiry in Firestore for monitoring
 * @param pageId - Facebook page ID
 * @param accessToken - Facebook page access token
 * @param options - Additional options
 * @returns Promise<void>
 */
export async function storePageToken(
  pageId: string, 
  accessToken: string, 
  options: StoreTokenOptions = {}
): Promise<void> {
  const { db = null, expiresInDays = TOKEN_EXPIRY_CONFIG.defaultExpiresDays } = options;
  const projectId = process.env.GCLOUD_PROJECT; // not stored in .env! Actually autogenerated by firebase
  const secretName = `facebook-token-${pageId}`; 
  // before we called our secret facebook-[pageId] but that was ambiguous.
  // We're talking bout __tokens__ here

  try {
    // create the secret (if it doesn't exist)
    await secretClient.createSecret({
      parent: `projects/${projectId}`,
      secretId: secretName,
      secret: {
        replication: { automatic: {} },
      },
    });
    logger.debug('Created new secret for page token', { secretName, pageId });
  } catch (error: any) {
    // if we failed to create the secret, it might not be because it's
    // __actually__ an error, but because it might already exist
    if (!error.message.includes('already exists')) {
      // If it's a real error (not "already exists"), we should fail fast
      // rather than trying to add a version to a potentially non-existent secret
      logger.error('Failed to create secret', error, { secretName, pageId });
      throw new Error(`Cannot store token: Secret creation failed for ${secretName}`);
    }
    // If it already exists, that's fine - we'll add a new version below
  }
  
  // secret version actually contains the data, kind of like firestore's 
  // snapshot object or http req/res objects. Here, it has a payload
  await secretClient.addSecretVersion({
    parent: `projects/${projectId}/secrets/${secretName}`,
    payload: {
      data: Buffer.from(accessToken),
      // buffer is just a temp data storage, esp in networks
    },
  });
  
  logger.info('Stored token for page in Secret Manager', { pageId });

  // Store token metadata in Firestore for expiry tracking
  if (db) {
    const now = Timestamp.now();
    const expiresAt = calculateExpirationDate(expiresInDays, now.toDate());
    
    await db.collection('pages').doc(pageId).set({
      tokenStoredAt: now,
      tokenExpiresAt: Timestamp.fromDate(expiresAt),
      tokenExpiresInDays: expiresInDays,
      tokenStatus: 'valid',
    }, { merge: true });
    
    logger.info('Stored token metadata in Firestore', {
      pageId,
      expiresAt: expiresAt.toISOString(),
      expiresInDays,
    });
  }
}

/**
 * Retrieve a Facebook page access token from Google Secret Manager
 * @param pageId - Facebook page ID
 * @returns The access token or null if not found
 */
export async function getPageToken(pageId: string): Promise<string | null> {
  // largely the same as the above create page token method, tho
  // a getter instead of a setter
  const projectId = process.env.GCLOUD_PROJECT; // against autogenerated by gcloud
  const secretName = `facebook-token-${pageId}`;
  
  try {
    const [version] = await secretClient.accessSecretVersion({
      name: `projects/${projectId}/secrets/${secretName}/versions/latest`,
    });
    return version.payload?.data?.toString() || null;
  } catch (error: any) {
    logger.warn('Failed to retrieve token from Secret Manager', {
      pageId,
      error: error.message,
    });
    return null;
  }
}

/**
 * Get the API key for authenticating manual sync requests
 * @returns The API key or null if not found
 */
export async function getApiKey(): Promise<string | null> {
  const projectId = process.env.GCLOUD_PROJECT; // auto-generated by gcloud
  const secretName = 'API_SYNC_KEY';
  
  try {
    const [version] = await secretClient.accessSecretVersion({
      name: `projects/${projectId}/secrets/${secretName}/versions/latest`,
    });
    return version.payload?.data?.toString() || null;
  } catch (error: any) {
    logger.error('Failed to retrieve API key from Secret Manager', error);
    return null;
  }
}

/**
 * Get the webhook verify token for Facebook webhook verification
 * This token is used by Facebook to verify that our webhook endpoint is legitimate
 * @returns The webhook verify token or null if not found
 */
export async function getWebhookVerifyToken(): Promise<string | null> {
  const projectId = process.env.GCLOUD_PROJECT;
  const secretName = 'WEBHOOK_VERIFY_TOKEN'; // this secret is in google secrets manager
  
  try {
    const [version] = await secretClient.accessSecretVersion({ // inbuilt method
      name: `projects/${projectId}/secrets/${secretName}/versions/latest`, 
    });
    return version.payload?.data?.toString() || null;
  } catch (error: any) {
    logger.error('Failed to retrieve webhook verify token from Secret Manager', error);
    return null;
  }
}

/**
 * Check if a page's token is expiring soon and needs refresh
 * @param db - Firestore instance
 * @param pageId - Facebook page ID
 * @param warningDays - Days before expiry to start warning (default: from TOKEN_EXPIRY_CONFIG)
 * @returns Token expiry status
 */
export async function checkTokenExpiry(
  db: admin.firestore.Firestore, 
  pageId: string, 
  warningDays: number = TOKEN_EXPIRY_CONFIG.warningDays
): Promise<TokenExpiryStatus> {
  const pageDoc = await db.collection('pages').doc(pageId).get();
  
  if (!pageDoc.exists || !pageDoc.data()?.tokenExpiresAt) {
    return { isExpiring: true, daysUntilExpiry: 0, expiresAt: null };
  }
  
  const expiresAt = pageDoc.data()!.tokenExpiresAt.toDate();
  const now = new Date();
  const daysUntilExpiry = calculateDaysUntilExpiry(expiresAt, now);
  
  return {
    isExpiring: isTokenExpiring(daysUntilExpiry, warningDays),
    daysUntilExpiry,
    expiresAt,
  };
}

/**
 * Mark a page's token as expired in Firestore
 * @param db - Firestore instance
 * @param pageId - Facebook page ID
 * @returns Promise<void>
 */
export async function markTokenExpired(
  db: admin.firestore.Firestore, 
  pageId: string
): Promise<void> {
  const { FieldValue } = require('@google-cloud/firestore');
  await db.collection('pages').doc(pageId).set({
    tokenStatus: 'expired',
    tokenExpiredAt: FieldValue.serverTimestamp(),
    active: false,
  }, { merge: true });
  
  logger.warn('Marked token as expired in Firestore', { pageId });
}

